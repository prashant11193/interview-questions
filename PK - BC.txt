Blenheim Chalcot : technical round : 10-11-2022 9:30am : zoom meeting : sr software engineer role :
-- LARAVEL
- what is middleware
    Middleware provide a convenient mechanism for inspecting and filtering HTTP requests entering our application. 
    For example, Laravel includes a middleware that verifies the user of our application is authenticated or not. 
    If the user is not authenticated, the middleware will redirect the user to our application's login screen. 
    However, if the user is authenticated, the middleware will allow the request to proceed further into the application.
    
    Middleware can be written to perform a variety of tasks besides authentication. 
    For example, a logging middleware might log all incoming requests to your application. All of these middleware are located in the app/Http/Middleware directory.

    A middleware can perform some task before or after the request is handled by the application.

    Global Middleware
    If we want a middleware to run during every HTTP request of our application, list the middleware class in the $middleware property of our app/Http/Kernel.php class.


- what is example set for middleware
    For example, a logging middleware might log all incoming requests to your application.
    a middleware that verifies the user of our application is authenticated or not.


- what is csrf token used for
    Cross-site request forgery (CSRF) are a type of malicious exploit whereby unauthorized commands are performed on behalf of an authenticated user.


- what is session
    sessions provide a way to store information about the user across multiple requests.
    session configuration file is stored at config/session.php.
    By default, Laravel is configured to use the file session driver, which will work well for many applications. If your application will be load balanced across multiple web servers, you should choose a centralized store that all servers can access, such as Redis or a database.
    The session driver configuration option defines where session data will be stored for each request.
    - driver options for storing sessions
        file - sessions are stored in storage/framework/sessions.
        cookie - sessions are stored in secure, encrypted cookies.
        database - sessions are stored in a relational database.
        memcached / redis - sessions are stored in one of these fast, cache based stores.
        dynamodb - sessions are stored in AWS DynamoDB.
        array - sessions are stored in a PHP array and will not be persisted.

    - Retrieving data
        There are two primary ways of working with session data in Laravel: the global session helper and via a Request instance.
        1. The session via a Request instance, which can be type-hinted on a route closure or controller method. 
        E.g 
            $value = $request->session()->get('key');
            $value = $request->session()->get('key', 'default');
 
            $value = $request->session()->get('key', function () {
                return 'default';
            });

        2. The global session PHP function to retrieve and store data in the session. 
            When the session helper is called with a single, string argument, it will return the value of that session key. 
            When the helper is called with an array of key / value pairs, those values will be stored in the session
        
        Retrieve a piece of data from the session...
            $value = session('key');
         
            // Specifying a default value...
            $value = session('key', 'default');
         
            // Store a piece of data in the session...
            session(['key' => 'value']);

            retrieve all the data in the session
            E.g
                $data = $request->session()->all();

            To determine if an item is present in the session, you may use the has method. The has method returns true if the item is present and is not null
            E.g
                if ($request->session()->has('users')) {}
            To determine if an item is present in the session, even if its value is null, you may use the exists method
            E.g
                if ($request->session()->exists('users')) {}
            To determine if an item is not present in the session, you may use the missing method. The missing method returns true if the item is not present
            E.g
                if ($request->session()->missing('users')) {}

        Storing Data in session
            To store data in the session, you will typically use the request instance's put method or the global session helper
            E.g
                // Via a request instance...
                $request->session()->put('key', 'value');
                 
                // Via the global "session" helper...
                session(['key' => 'value']);

            Pushing To Array Session Values
                The push method may be used to push a new value onto a session value that is an array. For example, if the user.teams key contains an array of team names, you may push a new value onto the array like
                E.g $request->session()->push('user.teams', 'developers');

        Retrieving & Deleting An Item
            The pull method will retrieve and delete an item from the session in a single statement
            E.g $value = $request->session()->pull('key', 'default');

        Incrementing & Decrementing Session Values
            $request->session()->increment('count');
             
            $request->session()->increment('count', $incrementBy = 2);
             
            $request->session()->decrement('count');
             
            $request->session()->decrement('count', $decrementBy = 2);

        Flash Data
            Sometimes you may wish to store items in the session for the next request. You may do so using the flash method. Data stored in the session using this method will be available immediately and during the subsequent HTTP request.
            E.g $request->session()->flash('status', 'Task was successful!');

            If you need to persist your flash data for several requests, you may use the reflash method, which will keep all of the flash data for an additional request. If you only need to keep specific flash data, you may use the keep method
            E.g
                $request->session()->reflash();
                $request->session()->keep(['username', 'email']);

            To persist your flash data only for the current request, you may use the now method:
            E.g $request->session()->now('status', 'Task was successful!');

        Deleting Data
            The forget method will remove a piece of data from the session. If you would like to remove all data from the session, you may use the flush method:
            E.g // Forget a single key...
                $request->session()->forget('name');
                 
                // Forget multiple keys...
                $request->session()->forget(['name', 'status']);
                 
                $request->session()->flush();

            Regenerating the session ID is often done in order to prevent malicious users from exploiting a session fixation attack on your application.
            E.g $request->session()->regenerate();

            If you need to regenerate the session ID and remove all data from the session in a single statement, you may use the invalidate method
            E.g $request->session()->invalidate();


- what does http kernel file hold (application's global HTTP middleware stack) console/kernel file the application's command schedule.
    The incoming request is sent to either the HTTP kernel or the console kernel, depending on the type of request that is entering the application. 
    These two kernels serve as the central location that all requests flow through.The HTTP kernel extends the Illuminate\Foundation\Http\Kernel class, 
    which defines an array of bootstrappers that will be run before the request is executed. These bootstrappers configure error handling, configure logging, 
    detect the application environment, and perform other tasks that need to be done before the request is actually handled.
    The HTTP kernel also defines a list of HTTP middleware that all requests must pass through before being handled by the application. 
    These middleware handle reading and writing the HTTP session, determining if the application is in maintenance mode, verifying the CSRF token, and more.
    The method signature for the HTTP kernel's handle method is quite simple: it receives a Request and returns a Response. 
    Think of the kernel as being a big black box that represents your entire application. Feed it HTTP requests and it will return HTTP responses.


- what is authorization and authentication (difference between both)
    Authentication (to verify a user's credentials and authenticate the user)
        How authentication works - When using a web browser, a user will provide their username and password via a login form. If these credentials are correct, the application will store information about the authenticated user in the user's session. A cookie issued to the browser contains the session ID so that subsequent requests to the application can associate the user with the correct session. After the session cookie is received, the application will retrieve the session data based on the session ID, note that the authentication information has been stored in the session, and will consider the user as "authenticated".
        When a remote service needs to authenticate to access an API, cookies are not typically used for authentication because there is no web browser. Instead, the remote service sends an API token to the API on each request. The application may validate the incoming token against a table of valid API tokens and "authenticate" the request as being performed by the user associated with that API token.
        Laravel provides two optional packages to assist you in managing API tokens and authenticating requests made with API tokens: Passport and Sanctum.

        Laravel's authentication facilities are made up of "guards" and "providers". Guards define how users are authenticated for each request. For example, Laravel ships with a session guard which maintains state using session storage and cookies.
        Providers define how users are retrieved from your persistent storage. Laravel ships with support for retrieving users using Eloquent and the database query builder. Your application's authentication configuration file is located at config/auth.php.
        We may access the authenticated user via the Auth facade's user method
        E.g
            use Illuminate\Support\Facades\Auth;
            
            // Retrieve the currently authenticated user...
            $user = Auth::user();
            
            // Retrieve the currently authenticated user's ID...
            $id = Auth::id();

            Determining If The Current User Is Authenticated
            use Illuminate\Support\Facades\Auth;
            
            if (Auth::check()) {
                // The user is logged in...
            }

            When the auth middleware detects an unauthenticated user, it will redirect the user to the login named route. You may modify this behavior by updating the redirectTo function in your application's app/Http/Middleware/Authenticate.php file:
            /**
            * Get the path the user should be redirected to.
            *
            * @param  \Illuminate\Http\Request  $request
            * @return string
            */
            protected function redirectTo($request)
            {
                return route('login');
            }
    
    Authorization (provides a simple way to authorize user actions against a given resource.)
         even though a user is authenticated, they may not be authorized to update or delete certain Eloquent models or database records managed by your application.Laravel's authorization features provide an easy, organized way of managing these types of authorization checks. Laravel provides two primary ways of authorizing actions: gates and policies. Think of gates and policies like routes and controllers. Gates provide a simple, closure-based approach to authorization while policies, like controllers, group logic around a particular model or resource.

        Gates
            Gates are simply closures that determine if a user is authorized to perform a given action. Typically, gates are defined within the boot method of the App\Providers\AuthServiceProvider class using the Gate facade. Gates always receive a user instance as their first argument and may optionally receive additional arguments such as a relevant Eloquent model.
            E.g to determine if a user can update a given App\Models\Post model. The gate will accomplish this by comparing the user's id against the user_id of the user that created the post
                use App\Models\Post;
                use App\Models\User;
                use Illuminate\Support\Facades\Gate;
                
                /**
                * Register any authentication / authorization services.
                *
                * @return void
                */
                public function boot()
                {
                    $this->registerPolicies();
                
                    Gate::define('update-post', function (User $user, Post $post) {
                        return $user->id === $post->user_id;
                    });
                }

                To authorize an action using gates, you should use the allows or denies methods provided by the Gate facade.
                    <?php
 
                    namespace App\Http\Controllers;
                    
                    use App\Http\Controllers\Controller;
                    use App\Models\Post;
                    use Illuminate\Http\Request;
                    use Illuminate\Support\Facades\Gate;
                    
                    class PostController extends Controller
                    {
                        /**
                        * Update the given post.
                        *
                        * @param  \Illuminate\Http\Request  $request
                        * @param  \App\Models\Post  $post
                        * @return \Illuminate\Http\Response
                        */
                        public function update(Request $request, Post $post)
                        {
                            if (! Gate::allows('update-post', $post)) {
                                abort(403);
                            }
                    
                            // Update the post...
                        }
                    }
        Policies 
            Policies are classes that organize authorization logic around a particular model or resource. For example, if your application is a blog, you may have a App\Models\Post model and a corresponding App\Policies\PostPolicy to authorize user actions such as creating or updating posts. Once the policy class has been created, it needs to be registered. Registering policies is how we can inform Laravel which policy to use when authorizing actions against a given model type. The App\Providers\AuthServiceProvider included with fresh Laravel applications contains a policies property which maps your Eloquent models to their corresponding policies. Registering a policy will instruct Laravel which policy to utilize when authorizing actions against a given Eloquent model.
            E.g 
                Once the policy class has been registered, you may add methods for each action it authorizes. For example, let's define an update method on our PostPolicy which determines if a given App\Models\User can update a given App\Models\Post instance.
                <?php
 
                    namespace App\Policies;
                    
                    use App\Models\Post;
                    use App\Models\User;
                    
                    class PostPolicy
                    {
                        /**
                        * Determine if the given post can be updated by the user.
                        *
                        * @param  \App\Models\User  $user
                        * @param  \App\Models\Post  $post
                        * @return bool
                        */
                        public function update(User $user, Post $post)
                        {
                            return $user->id === $post->user_id;
                        }
                    }

        NOTE : By default, all gates and policies automatically return false if the incoming HTTP request was not initiated by an authenticated user.


- what is eloquent
    Eloquent is an object-relational mapper (ORM) that makes it easy to interact with our database. When using Eloquent, each database table has a corresponding "Model" that is used to interact with that table. In addition to retrieving records from the database table, Eloquent models allow you us to insert, update, and delete records from the table as well.

    A mass assignment vulnerability occurs when a user passes an unexpected HTTP request field and that field changes a column in your database that you did not expect. For example, a malicious user might send an is_admin parameter through an HTTP request, which is then passed to your model's create method, allowing the user to escalate themselves to an administrator.

    The destroy method loads each model individually and calls the delete method so that the deleting and deleted events are properly dispatched for each model.

    Eloquent models dispatch several events, allowing you to hook into the following moments in a model's lifecycle: retrieved, creating, created, updating, updated, saving, saved, deleting, deleted, trashed, forceDeleted, restoring, restored, and replicating.
    To start listening to model events, define a $dispatchesEvents property on your Eloquent model.
    E.g 
        /**
        * The event map for the model.
        *
        * @var array
        */
        protected $dispatchesEvents = [
            'saved' => UserSaved::class,
            'deleted' => UserDeleted::class,
        ];

    NOTE : When issuing a mass update or delete query via Eloquent, the saved, updated, deleting, and deleted model events will not be dispatched for the affected models. This is because the models are never actually retrieved when performing mass updates or deletes.

    You may occasionally need to temporarily "mute" all events fired by a model. You may achieve this using the withoutEvents method. The withoutEvents method accepts a closure as its only argument. Any code executed within this closure will not dispatch model events, and any value returned by the closure will be returned by the withoutEvents method
        use App\Models\User;
    
        $user = User::withoutEvents(function () {
            User::findOrFail(1)->delete();
        
            return User::find(2);
        });
    
    Sometimes you may wish to "save" a given model without dispatching any events. You may accomplish this using the saveQuietly method
        $user = User::findOrFail(1);
        $user->name = 'Victoria Faith';
        $user->saveQuietly();
    

- what are pros and cons of using eloquent. When will you use eloquent and raw db querying.
    1. Renaming a table name is easy with eloquent as we just need to add/modify $table property in our model file.
    2. Readability - if the query gets complicated it harded to understand the raw queries as we need to manage multiple join query.
    3. raw query is musch faster comparitive 50% (when loading a relationships data as well)
        E.g $products = Product::with('category')->get(); // takes 1000ms becuase we have query for eager loading relationships and also have select query for products
            $products = DB::table('products')->join('product_categories','products.product_category_id','=','product_categories.id')->get(); // take 670ms because it has only 1 query i.e select and inner join
    4. Eloquent provides additional functions that can be performed after the result is fetched like updating the field in loop or deleting the model. we can fetch the relational property and append custom text to it, soft deleting the records.
    5.Accessor -  we can fetch the data via accessors e.g for the field that returns percetage value, we can define the accessor in model and just loop the result and display the percentage value.


- current version of laravel
    Laravel - 9.X
    NOTE : Laravel v10 is the next major version of Laravel, planned for release on February 7th, 2023.


- difference between laravel 8 and 9
    Accessor & Mutator
        In Laravel 9.x you may define an accessor and mutator using a single, non-prefixed method by type-hinting a return type of Illuminate\Database\Eloquent\Casts\Attribut
        
        use Illuminate\Database\Eloquent\Casts\Attribute;
        public function name(): Attribute
        {
            return new Attribute(
                get: fn ($value) => strtoupper($value),
                set: fn ($value) => $value,
            );
        }

    Controller Route Groups
        You may now use the controller method to define the common controller for all of the routes within the group. Then, when defining the routes, you only need to provide the controller method that they invoke:
            use App\Http\Controllers\OrderController;
            Route::controller(OrderController::class)->group(function () {
                Route::get('/orders/{id}', 'show');
                Route::post('/orders', 'store');
            });
    
    Rendering Inline Blade Templates
        The render method accepts the Blade template string and an optional array of data to provide to the template
        use Illuminate\Support\Facades\Blade;
        return Blade::render('Hello, {{ $name }}', ['name' => 'Julian Bashir']);

    Slot Name Shortcut
        slot names were provided using a name attribute on the x-slot tag
        <x-alert>
            <x-slot name="title">
                Server Error
            </x-slot>
            <strong>Whoops!</strong> Something went wrong!
        </x-alert>

        Laravel 9.x, you may specify the slot's name using a convenient, shorter syntax
            <x-slot:title>Server Error</x-slot>
        
    Checked / Selected Blade Directives
        The @checked directive to easily indicate if a given HTML checkbox input is "checked". This directive will echo checked if the provided condition evaluates to true
        <input type="checkbox" name="active" value="active" @checked(old('active', $user->active)) />
        The @selected directive may be used to indicate if a given select option should be "selected".
            <select name="version">
                @foreach ($product->versions as $version)
                    <option value="{{ $version }}" @selected(old('version') == $version) @checked(old('active', $user->active))>
                        {{ $version }}
                    </option>
                @endforeach
            </select>

    Helper Functions
        The str function returns a new Illuminate\Support\Stringable instance for the given string.
        $string = str('Taylor')->append(' Otwell');

        The to_route function generates a redirect HTTP response for a given named route, providing an expressive way to redirect to named routes from your routes and controllers
        return to_route('users.show', ['user' => 1]);


- explain entire request lifecycle in laravel
    1. First step 
        The entry point for all requests to a Laravel application is the public/index.php file. All requests are directed to this file by your web server (Apache / Nginx) configuration. The index.php file doesn't contain much code. Rather, it is a starting point for loading the rest of the framework.
        The index.php file loads the Composer generated autoloader definition, and then retrieves an instance of the Laravel application from bootstrap/app.php. The first action taken by Laravel itself is to create an instance of the application / service container.

    2. HTTP / Console Kernels
        Next, the incoming request is sent to either the HTTP kernel or the console kernel, depending on the type of request that is entering the application. These two kernels serve as the central location that all requests flow through. For now, let's just focus on the HTTP kernel, which is located in app/Http/Kernel.php.
        The HTTP kernel extends the Illuminate\Foundation\Http\Kernel class, which defines an array of bootstrappers that will be run before the request is executed. These bootstrappers configure error handling, configure logging, detect the application environment, and perform other tasks that need to be done before the request is actually handled.
        The HTTP kernel also defines a list of HTTP middleware that all requests must pass through before being handled by the application. These middleware handle reading and writing the HTTP session, determining if the application is in maintenance mode, verifying the CSRF token, and more.
        The method signature for the HTTP kernel's handle method is quite simple: it receives a Request and returns a Response.

    3. Service Providers
        One of the most important kernel bootstrapping actions is loading the service providers for your application. Service providers are responsible for bootstrapping all of the framework's various components, such as the database, queue, validation, and routing components. All of the service providers for the application are configured in the config/app.php configuration file's providers array.
        
        Laravel will iterate through this list of providers and instantiate each of them. After instantiating the providers, the register method will be called on all of the providers. Then, once all of the providers have been registered, the boot method will be called on each provider. This is so service providers may depend on every container binding being registered and available by the time their boot method is executed.

    4. Routing
        One of the most important service providers in your application is the App\Providers\RouteServiceProvider. This service provider loads the route files contained within your application's routes directory.
        Once the application has been bootstrapped and all service providers have been registered, the Request will be handed off to the router for dispatching. The router will dispatch the request to a route or controller, as well as run any route specific middleware.
        Middleware provide a convenient mechanism for filtering or examining HTTP requests entering your application.
        For example, Laravel includes a middleware that verifies if the user of your application is authenticated. If the user is not authenticated, the middleware will redirect the user to the login screen. However, if the user is authenticated, the middleware will allow the request to proceed further into the application. Some middleware are assigned to all routes within the application, like those defined in the $middleware property of your HTTP kernel, while some are only assigned to specific routes or route groups.
        If the request passes through all of the matched route's assigned middleware, the route or controller method will be executed and the response returned by the route or controller method will be sent back through the route's chain of middleware.

    5. Finishing Up
        Once the route or controller method returns a response, the response will travel back outward through the route's middleware, giving the application a chance to modify or examine the outgoing response.

        Finally, once the response travels back through the middleware, the HTTP kernel's handle method returns the response object and the index.php file calls the send method on the returned response. The send method sends the response content to the user's web browser. We've finished our journey through the entire Laravel request lifecycle!

    6. Focus On Service Providers
        Service providers are truly the key to bootstrapping a Laravel application. The application instance is created, the service providers are registered, and the request is handed to the bootstrapped application. It's really that simple! application's default service providers are stored in the app/Providers directory.
        By default, the AppServiceProvider is fairly empty. This provider is a great place to add your application's own bootstrapping and service container bindings.


- what are in built packages used by laravel- what is 02auth and passport
    - Artisan
        Artisan is the command line interface included with Laravel. Artisan exists at the root of your application as the artisan script and provides a number of helpful commands that can assist you while you build your application. To view a list of all available Artisan commands, you may use the list command:
        php artisan list //displays all the command's availables.
        php artisan help migrate //displays and describes the command's available arguments and options.

    - tinker
        Laravel Tinker is a powerful REPL(Read Evaluate Print Loop) for the Laravel framework. All Laravel applications include Tinker by default. Tinker allows you to interact with your entire Laravel application on the command line, including your Eloquent models, jobs, events, and more. To enter the Tinker environment, run the tinker Artisan command: php artisan tinker


    - phpunit
        By default, your application's tests directory contains two directories: Feature and Unit. Unit tests are tests that focus on a very small, isolated portion of your code. In fact, most unit tests probably focus on a single method. Tests within your "Unit" test directory do not boot your Laravel application and therefore are unable to access your application's database or other framework services.

        Feature tests may test a larger portion of your code, including how several objects interact with each other or even a full HTTP request to a JSON endpoint. Generally, most of your tests should be feature tests. These types of tests provide the most confidence that your system as a whole is functioning as intended.

        An ExampleTest.php file is provided in both the Feature and Unit test directories. After installing a new Laravel application, execute the vendor/bin/phpunit or php artisan test commands to run your tests.

    
- what are facades
    A facade is a class that provides access to an object from the container. The machinery that makes this work is in the Facade class. Laravel's facades, and any custom facades you create, will extend the base Illuminate\Support\Facades\Facade class. Facades provide a "static" interface to classes that are available in the application's service container. All of Laravel's facades are defined in the Illuminate\Support\Facades namespace. So, we can easily access a facade like
        use Illuminate\Support\Facades\Cache;
        use Illuminate\Support\Facades\Route;
        
        Route::get('/cache', function () {
            return Cache::get('key');
        });
    
    The Facade base class makes use of the __callStatic() magic-method to defer calls from your facade to an object resolved from the container. Any calls we make using the facade will be passed to the underlying instance of Laravel's cache service. If we look at that Illuminate\Support\Facades\Cache class, you'll see that there is no static method get
        class Cache extends Facade
        {
            /**
            * Get the registered name of the component.
            *
            * @return string
            */
            protected static function getFacadeAccessor() { 
                return 'cache'; // name of the service container binding.
            }
        }

    Instead, the Cache facade extends the base Facade class and defines the method getFacadeAccessor(). This method's job is to return the name of a service container binding. When a user references any static method on the Cache facade, Laravel resolves the cache binding from the service container and runs the requested method (in this case, get) against that object.


- what do you mean by object in facades
    Instead, the Cache facade extends the base Facade class and defines the method getFacadeAccessor(). This method's job is to return the name of a service container binding. When a user references any static method on the Cache facade, Laravel resolves the cache binding from the service container and runs the requested method (in this case, get) against that object.


- what is throttling
    Throttling is a mechanism were the user will not be able to login for one minute if they fail to provide the correct credentials after several attempts.
    The throttling is unique to the user's username / email address and their IP address.


- what are events? can you give an example
    Laravel's events provide a simple observer pattern implementation, allowing you to subscribe and listen for various events that occur within your application. Event classes are typically stored in the app/Events directory, while their listeners are stored in app/Listeners.
    Events serve as a great way to decouple various aspects of your application, since a single event can have multiple listeners that do not depend on each other. For example, you may wish to send a Slack notification to your user each time an order has shipped. Instead of coupling your order processing code to your Slack notification code, you can raise an App\Events\OrderShipped event which a listener can receive and use to dispatch a Slack notification.
    Events can be implemented using observers on model at the time of creating, storing, updating & deleting the model record.


- what is channel.php and console.php file in routes folder
    The routes directory contains all of the route definitions for your application. By default, several route files are included with Laravel: web.php, api.php, console.php, and channels.php.

    web.php - The web.php file contains routes that the RouteServiceProvider places in the web middleware group, which provides session state, CSRF protection, and cookie encryption. If your application does not offer a stateless, RESTful API then all your routes will most likely be defined in the web.php file.

    api.php - The api.php file contains routes that the RouteServiceProvider places in the api middleware group. These routes are intended to be stateless, so requests entering the application through these routes are intended to be authenticated via tokens and will not have access to session state.

    console.php - The console.php file is where you may define all of your closure based console commands. Each closure is bound to a command instance allowing a simple approach to interacting with each command's IO methods. It defines console based entry points (routes) into your application.

    channels.php - The channels.php file is where you may register all of the event broadcasting channels that your application supports.


-- SQL
- what are different storage engines (innodb, myisam)
    A storage engine is a software module that a database management system uses to create, read, update data from a database. 
    There are two types of storage engines in MySQL: transactional and non-transactional.

    For MySQL 5.5 and later, the default storage engine is InnoDB. The default storage engine for MySQL prior to version 5.5 was MyISAM. 
    Choosing the right storage engine is an important strategic decision, which will impact future development.
    
    InnoDB
        The most widely used storage engine with transaction support.
        It supports row-level locking, crash recovery and multi-version concurrency control.
        It is the only engine which provides foreign key referential integrity constraint.
    
    MyISAM
        MyISAM is the original storage engine.
        It is a fast storage engine.
        It does not support transactions. 
        MyISAM provides table-level locking. 
        It is used mostly in Web and data warehousing.

    CSV - Stores data in Comma Separated Value format in a text file.


- what is the difference between innodb and myisam db 
    MyISAM does not support foreign keys , not supports transaction. You cannot commit and rollback with MYISAM. Once you issue a command it’s done.
    MYISAM supports Table-level Locking, MyISAM designed for need of speed.


- what is normalization
    The process of organizing data in a database. This includes creating tables and establishing relationships between those tables according to rules designed both to protect the data and to make the database more flexible by eliminating redundancy and inconsistent dependency.
    It is a multi-step process that sets the data into tabular form and removes the duplicated data from the relational tables.
    Redundant data wastes disk space and creates maintenance problems. If data that exists in more than one place must be changed, the data must be changed in exactly the same way in all locations.
    

- What is ddl dml dcl in sql and it's commands
    SQL(Structured Query Language) uses certain commands like Create, Drop, Insert, etc. to carry out the required tasks.
    SQL commands are mainly categorized into five categories
        DCL – Data Control Language         (Grant & Revoke)
                Mainly deal with the rights, permissions, and other controls of the database system.
                GRANT: This command gives users access privileges to the database.
                REVOKE: This command withdraws the user’s access privileges given by using the GRANT command.

        DDL – Data Definition Language      (Create, Drop, Alter, Comment, Rename & Truncate)
                Used to define the database schema.
                DDL is a set of SQL commands used to create, modify, and delete database structures but not data.
                CREATE: This command is used to create the database or its objects (like table, index, function, views, store procedure, and triggers).
                DROP: This command is used to delete objects from the database.
                ALTER: This is used to alter the structure of the database.
                TRUNCATE: This is used to remove all records from a table, including all spaces allocated for the records are removed.
                COMMENT: This is used to add comments to the data dictionary.
                RENAME: This is used to rename an object existing in the database.

        DML – Data Manipulation Language    (Insert, Update, Delete & Lock)
                Used for manipulation of data present in the database.
                INSERT : It is used to insert data into a table.
                UPDATE: It is used to update existing data within a table.
                DELETE : It is used to delete records from a database table.
                LOCK: Table control concurrency.

        DQL – Data Query Language           (select)
                Used for performing queries on the data within schema objects.
                It is used to retrieve data from the database.

        TCL – Transaction Control Language  (Commit, Savepoint, Rollback, Set transaction & Set constraint)
                Transactions group a set of tasks into a single execution unit.
                Each transaction begins with a specific task and ends when all the tasks in the group successfully complete.
                If any of the tasks fail, the transaction fails. Therefore, a transaction has only two results: success or failure.
                COMMIT: Commits a Transaction.
                ROLLBACK: Rollbacks a transaction in case of any error occurs.
                SAVEPOINT: Sets a save point within a transaction.
                SET TRANSACTION: Specifies characteristics for the transaction.


- sql to fetch third highest salary of an employee
    Solution :
        SELECT DISTINCT `salary` FROM `employees` ORDER BY `salary` DESC LIMIT 1 OFFSET 1;
        // limit 1 - will fetch only 1 record
        // offset 1 will discard the starting numbers of row mentioned here 1 row will be discarded and this will fetch 2nd highest salary employee

        -- Return 3rd highest salary with no regards of same salary. i.e. Brian Kernighan
        SELECT * FROM `employee` ORDER BY `salary` DESC LIMIT 1 OFFSET 2;

        -- Return 3rd highest salary with distincation. Can return multiple rows matched.
        SELECT * FROM `employee` WHERE `Salary` = (SELECT DISTINCT `Salary` FROM `employee` ORDER BY `salary` DESC LIMIT 1 OFFSET 2);

        -- Return 3rd highest salary with distincation. Limiting to 1 result.
        SELECT * FROM `employee` WHERE `Salary` = (SELECT DISTINCT `Salary` FROM `employee` ORDER BY `salary` DESC LIMIT 1 OFFSET 2) LIMIT 1;


- what are aggregate functions
    A function where the values of multiple rows are grouped together as input on certain criteria to form a single value of more significant meaning.
    Count()
    Sum()
    Avg()
    Min()
    Max()


- what is ddos attack
    A distributed denial-of-service (DDoS) attack is a malicious attempt to disrupt the normal traffic of a targeted server, service or network by overwhelming the target or its surrounding infrastructure with a flood of Internet traffic.
    A DDoS attack is like an unexpected traffic jam clogging up the highway, preventing regular traffic from arriving at its destination.


- what is owasp
    Open Web Application Security Project(OWASP) is a nonprofit foundation that works to improve the security of the software.
    The project focuses on providing good security practices for builders in order to secure their applications.


-- GIT
- how do you merge git requests
    via github or via command line
        git checkout feature
        git merge main
            Or
        git merge feature main

    This command will combine multiple sequences of commits into one unified history. In the most frequent use cases, git merge is used to combine two branches. The git merge command takes two commit pointers, usually the branch tips, and finds a common base commit between them. Once it finds a common base commit, it will create a commit sequence.
    

- what is the difference between git fetch and git pull
    Git Fetch 
        Git Fetch is the command that tells the local repository that there are changes available in the remote repository without bringing the changes into the local repository.
        git fetch = git merge
    Git Pull    
        Git Pull on the other hand brings the copy of the remote directory changes into the local repository.
        git pull = git fetch + git merge
    
    Difference
        GF - Gives the information of a new change from a remote repository without merging into the current branch
        GP - Brings the copy of all the changes from a remote repository and merges them into the current branch

        GF - Repository data is updated in the .git directory
        GP - The local repository is updated directly
 
        GF - Review of commits and changes can be done
        GP - Updates the changes to the local repository immediately.

        GF - No possibility of merge conflicts.
        GP - Merge conflicts are possible if the remote and the local repositories have done changes at the same place.

        GF - Command for Git fetch is git fetch<remote>
        GP - Command for Git Pull is git pull<remote><branch>

        GF - Git fetch basically imports the commits to local branches so as to keep up-to-date that what everybody is working on.
        GP - Git Pull basically brings the local branch up-to-date with the remote copy that will also updates the other remote tracking branches.


- what is the the staging branch in git
    The staging environment is as similar to production as possible.
    The idea is that if a feature is running perfectly fine in staging, it will run in production also.
    Generally, the acceptance tests are carried out in this environment, but depending on the testing model, it can be carried out in the development environment also.
    Smoke tests and most of the performance, reliability, security and availability testings will be carried out in this environment.
    All pre customer releases will be made in this environment. The customers/clients will be shown a demo in this environment before releasing it to production and making the application live.


- where is the data stored when we commit changes
    The staging area can be described as a preview of your next commit. When you create a git commit, Git takes changes that are in the staging area and make them as a new commit. You are allowed to add and remove changes from the staging area. The staging area can be considered as a real area where git stores the changes.
    Changes are stored in staging area in .index file.


- what is the command to revert back the pushed changes
    git revert <commit hash> . 
    You can undo the latest commit with git reset --soft HEAD^ too. But if you already pushed your changes a revert could be a better option


- git stash
    "git stash"
    This command can be used when we want to save our work without staging or committing the code to our Git repository and want to switch between branches.
    
    "git stash -u"
        command is used when we want to stash the untracked files.
    
    "git stash pop"
        This command is used when we are back on our branch and want to retrieve the code.

    Note that the stash is local to your Git repository; stashes are not transferred to the server when you push.


- git revert [commit id]
    The git revert command can be considered as an ‘undo’ command. However, it does not work as the traditional ‘undo’ operation.
    It figures out how to invert the changes introduced by the commit and appends a new commit with the resulting inverse content.


- git diff
    Usage: git diff commit-id-of-version-x commit-id-of-version-y

    Diffing is a function that takes two input datasets and outputs the changes between them. The git diff command is a multi-use Git command which, when executed, runs a diff function on Git data sources. These data sources can be commits, branches, files, and more. The git diff command is often used along with the git status and git log commands to analyze the current state of our Git repository. We use git log to get the details of commit IDs.


- git rebase
    Usage: git rebase master
    Rebase is the process of moving and combining a sequence of commits to a new base commit. Rebasing is changing the base of our branch from one commit to another, making it appear as if we’ve created our branch from a different commit. Internally, Git accomplishes this by creating new commits and applying them to the specified base. It’s very important to understand that even though the branch looks the same, it is composed of entirely new commits.
    The git rebase command performs an automatic git checkout <branch> before doing anything else. Otherwise, it remains on the current branch.


- git reset --hard
    We use this command to return the entire working tree to the last committed state.
    This will discard commits in a private branch or throw away the uncommitted changes!
    If we do git reset -–hard [SOME-COMMIT], then Git will:
    Make our current branch (typically master) back to point <SOME-COMMIT>
    Make the files in our working tree and the index (“staging area”) the same as the versions committed at <SOME-COMMIT>